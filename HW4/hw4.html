<!DOCTYPE html>
<html>
<head>
<style>
#info
{
  position: absolute;
  top: 10px;
  width: 100%;
  padding: 5px;
  text-align: center;
  font-size:20px;
  color: #ffff00
}

body {
  overflow: hidden;
}
</style>
</head>

<body>
<div id="info">HW4  <br>

</div>
<script src="https://threejs.org/build/three.min.js"></script>
<script src="https://threejs.org/examples/js/controls/OrbitControls.js">
</script>
<script src="https://jyunming-chen.github.io/tutsplus/js/KeyboardState.js"></script>
<script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
<script src="https://threejs.org/examples/js/misc/Gyroscope.js"></script>
<script src="https://raw.githack.com/mrdoob/three.js/dev/examples/js/loaders/MTLLoader.js"></script>
  <script src="https://raw.githack.com/mrdoob/three.js/dev/examples/js/loaders/OBJLoader.js"></script>


<script>
var theObject;

var mouseX = 0,
  mouseY = 0;

var windowHalfX = window.innerWidth / 2;
var windowHalfY = window.innerHeight / 2;
var controls;
var bs;
var modelName;
var theModel;

  function readModel (modelName, targetSize=150) {

  var onProgress = function(xhr) {
    if (xhr.lengthComputable) {
      var percentComplete = xhr.loaded / xhr.total * 100;
      console.log(Math.round(percentComplete, 2) + '% downloaded');
    }
  };

  var onError = function(xhr) {};

  var mtlLoader = new THREE.MTLLoader();
  mtlLoader.setPath('models/');
  mtlLoader.load(modelName+'.mtl', function(materials) {

    materials.preload();

    var objLoader = new THREE.OBJLoader();
    objLoader.setMaterials(materials);
    objLoader.setPath('models/');
    objLoader.load(modelName+'.obj', function(object) {
    
     bus =  unitize (object, targetSize);
    //theObject.add ( new THREE.BoxHelper (theObject) )
    bus.name = 'OBJ'
    scene.add (bus);
    
    bus.setRotationFromEuler (new THREE.Euler (3.1416/2, 0, -3.1416/2, 'ZYX'))
    //把公車轉正
    bus.rotation.x += -Math.PI;
    bus.rotation.y += Math.PI/2;
    }, onProgress, onError);

  });

}

function unitize (object, targetSize) {  
  
  // find bounding box of 'object'
  var box3 = new THREE.Box3();
  box3.setFromObject (object);
  var size = new THREE.Vector3();
  size.subVectors (box3.max, box3.min);
  var center = new THREE.Vector3();
  center.addVectors(box3.max, box3.min).multiplyScalar (0.5);
  
  console.log ('center: ' + center.x + ', '+center.y + ', '+center.z );
  console.log ('size: ' + size.x + ', ' +  size.y + ', '+size.z );
  
  // uniform scaling according to objSize
  var objSize = Math.max (size.x, size.y, size.z);
  var scaleSet = targetSize/objSize;
        
  var theObject =  new THREE.Object3D();
  theObject.add (object);
  object.scale.set (scaleSet, scaleSet, scaleSet);
  object.position.set (-center.x*scaleSet, -center.y*scaleSet, -center.z*scaleSet);
  
  return theObject;
      
}

////////////////////////////////////////
class Obstacle {
  constructor (center,size) {
    this.center = center.clone();  
    this.mesh = new THREE.Mesh (new THREE.CylinderGeometry(size,size,1,20),
      new THREE.MeshBasicMaterial());
    this.mesh.position.copy (center);
    this.size = size;
    scene.add (this.mesh)
  }
}

function clamp (val, min, max) { // min <= val <= max
   return Math.min(Math.max(val,min),max);
}

class Agent {
  constructor(pos, group) {
    this.pos = pos.clone();
    this.vel = new THREE.Vector3();
    this.force = new THREE.Vector3();
    this.target = null;
    this.size = 3;
    this.model = group;
    scene.add (group);
    
    this.MAXSPEED = 150;
    this.ARRIVAL_R = 30;
    
    // for orientable agent
    this.angle = 0;
  }
  
  update(dt) {
    this.accumulateForce();
    this.vel.add(this.force.clone().multiplyScalar(dt));

    // ARRIVAL: velocity modulation
    if (this.target !== null) {   
      let dst = this.target.distanceTo(this.pos);
      if (dst < this.ARRIVAL_R) {  // close enough
        this.vel.setLength(dst);
      }
    }
    
    // MAXSPEED modulation
    let speed = this.vel.length()
    this.vel.setLength(clamp (speed, 0, this.MAXSPEED))
    this.pos.add(this.vel.clone().multiplyScalar(dt))
    this.model.position.copy(this.pos)
    
    // for orientable agent
    // non PD version
    if (this.vel.length() > 0.1) {
        this.angle = Math.atan2 (-this.vel.z, this.vel.x)
        this.model.rotation.z = this.angle


    }

  }
  
  setTarget(x,y,z) {
    if (this.target !== null)
      this.target.set(x,y,z);
    else {
      this.target = new THREE.Vector3(x,y,z);
    }
  }
  
  targetInducedForce(targetPos) { // seek
    return targetPos.clone().sub(this.pos).setLength(this.MAXSPEED).sub(this.vel);
  }

  accumulateForce() {
    if (this.target) 
      this.force.copy(this.targetInducedForce(this.target));
  }

}
var T=1;
class human{
constructor(WW,HH){
     this.WW=WW;
     this.HH=HH;
     this.pos=new THREE.Vector3(0,0,0);
     this.vel=new THREE.Vector3(0,0,0);
     this.force=new THREE.Vector3(0,0,0);
     this.power=0.5;
     this.angle=0;   
     this.target=null;

     this.MAXSPEED = 60;
     this.ARRIVAL_R = 30;

     this.pose1 = {
  lThigh: Math.PI/6,
  rThigh: -Math.PI/6
}
this.pose2 = {
  lThigh: -Math.PI/6,
  rThigh: +Math.PI/6
}
this.keys = [
  [0, this.pose1],
  [0.5, this.pose2],
  [1, this.pose1]
];
}

update(dt){
    this.setTarget (agent.model.position.x+50,5,agent.model.position.z+50);
    this.accumulateForce();
    this.vel.add(this.force.clone().multiplyScalar(dt));

    // ARRIVAL: velocity modulation
    if (this.target !== null) {   
      let dst = this.target.distanceTo(this.pos);
      if (dst < this.ARRIVAL_R) {  // close enough
        this.vel.setLength(dst);
      }
    }
    
    // MAXSPEED modulation
    let speed = this.vel.length()
    this.vel.setLength(clamp (speed, 0, this.MAXSPEED))
    this.pos.add(this.vel.clone().multiplyScalar(dt))
    this.torso.position.copy(this.pos)

    // for orientable agent
    // non PD version
    if (this.vel.length() > 0.1) {
        this.angle = Math.atan2 (-this.vel.z, this.vel.x)
        this.torso.rotation.y = this.angle
        let intKey=this.keyframe(clock.getElapsedTime());
                this.lArm.rotation.z = intKey[1];
                this.rArm.rotation.z = intKey[0];
                this.lLeg.rotation.z = intKey[0];
                this.rLeg.rotation.z = intKey[1];
    }
   }
   
  keyframe(t){
  var s = ((t - ts) % T) / T;

  for (var i = 1; i < this.keys.length; i++) {
    if (this.keys[i][0] > s) break;
  }
  // take i-1
  var ii = i - 1;
  var a = (s - this.keys[ii][0]) / (this.keys[ii + 1][0] - this.keys[ii][0]);
  let intKey = [this.keys[ii][1].lThigh * (1 - a) + this.keys[ii + 1][1].lThigh * a,
            this.keys[ii][1].rThigh * (1 - a) + this.keys[ii + 1][1].rThigh * a
  ];
  return intKey;
  } 

buildHuman(WW,HH){

  this.head = this.buildHead(WW,HH);
  this.torso = this.buildTorso(WW,HH);
  this.torso.add (this.head);
  this.head.position.y = HH;
  this.torso.position.set (0, HH, 0);
  
  this.lLeg = this.buildLLeg(WW,HH);
  this.torso.add (this.lLeg);
  this.lLeg.position.set (0, 0, WW/2);
  
  this.rLeg = this.buildRLeg(WW,HH);
  this.torso.add (this.rLeg);
  this.rLeg.position.set (0, 0, -WW/2);

  this.lArm = this.buildLArm(WW,HH);
  this.torso.add (this.lArm);
  this.lArm.position.set (0, HH, WW+2);
  
  this.rArm = this.buildRArm(WW,HH);
  this.torso.add (this.rArm);
  this.rArm.position.set (0, HH, -WW-2);

  scene.add (this.torso);
  this.lLeg.rotation.z = Math.PI/6;
  this.rLeg.rotation.z =-Math.PI/6;
  }
   buildHead(WW,HH) {
  let head = new THREE.Group();
  let mesh = new THREE.Mesh (new THREE.BoxGeometry(2*WW,2*WW,2*WW), new THREE.MeshNormalMaterial());
  head.add (mesh);
  mesh.position.y = WW;
  return head;
  }

  buildLLeg(WW,HH) {
  let lLeg = new THREE.Group();
  let mesh = new THREE.Mesh (new THREE.BoxGeometry(WW,HH,WW), new THREE.MeshNormalMaterial());
  lLeg.add (mesh);
  mesh.position.y = -HH/2;
  return lLeg;
  }
  buildRLeg(WW,HH) {
  let rLeg = new THREE.Group();
  let mesh = new THREE.Mesh (new THREE.BoxGeometry(WW,HH,WW), new THREE.MeshNormalMaterial());
  rLeg.add (mesh);
  mesh.position.y = -HH/2;
  return rLeg;
  }

  buildTorso(WW,HH) {
  let torso = new THREE.Group();
  let mesh = new THREE.Mesh (new THREE.BoxGeometry(1*WW,HH,2*WW), new THREE.MeshNormalMaterial());
  torso.add (mesh);
  mesh.position.y = HH/2;

  return torso;
  }

  buildLArm(WW,HH){
  let lArm = new THREE.Group();
  let mesh = new THREE.Mesh (new THREE.BoxGeometry(WW,HH,WW), new THREE.MeshNormalMaterial());
  lArm.add (mesh);
  mesh.position.y = -HH/2;
  return lArm;
  }

  buildRArm(WW,HH){
  let rArm = new THREE.Group();
  let mesh = new THREE.Mesh (new THREE.BoxGeometry(WW,HH,WW), new THREE.MeshNormalMaterial());
  rArm.add (mesh);
  mesh.position.y = -HH/2;
  return rArm;
  }

  setTarget(x,y,z) {
    if (this.target !== null)
      this.target.copy(agent.model.localToWorld(new THREE.Vector3(35,-25,-4)));
    else {
      this.target = new THREE.Vector3(x,y,z);
    }
  }
  
  targetInducedForce(targetPos) { // seek
    return targetPos.clone().sub(this.pos).setLength(this.MAXSPEED).sub(this.vel);
  }

  accumulateForce() {
    if (this.target) 
      this.force.copy(this.targetInducedForce(this.target));
  }

}
/*
function findNbhd(agents) {
  let i, j, dst;
  let nAgents = agents.length;
  
  // 這樣的 double-for-loop對嗎？
  agents.forEach(function(agent){agent.nbhd=[]});
  
  for (i = 0; i < nAgents - 1; i++) {
    for (j = i + 1; j < nAgents; j++) {
      dst = agents[i].distanceTo(agents[j])
      if (dst < 20) { // NBHD = 20
        agents[i].addNbr(agents[j])
        agents[j].addNbr(agents[i])
      }
    }
  }
}
*/
////////////////////
var camera, scene, renderer, clock;
var raycaster;
var mouse = new THREE.Vector2();
var pickables = [];
var agent;
var targetMesh;
var bus;
var clock = new THREE.Clock();
var ts = clock.getElapsedTime();
var WW=4,HH=12;

init();
animate();


function init() {

  clock = new THREE.Clock();
  scene = new THREE.Scene();

  camera = new THREE.PerspectiveCamera(100, window.innerWidth / window.innerHeight, 10, 1000);
  camera.position.z = 120;
  camera.position.y = 150;

  //var gridXZ = new THREE.GridHelper(300, 30, 'red', 'white');
  //scene.add(gridXZ);
  var floor = new THREE.Mesh(new THREE.PlaneGeometry(1000,1000),new THREE.MeshPhongMaterial({color: 0x696969,shininess: 10,side:THREE.DoubleSide,}))
  floor.rotation.x = -Math.PI/2;
  scene.add(floor);


  renderer = new THREE.WebGLRenderer();
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setClearColor(0x888888);

  let controls = new THREE.OrbitControls(camera, renderer.domElement);

  document.body.appendChild(renderer.domElement);

  /////////////////////////////////////////////////////////////////////
  let plane = new THREE.Mesh(new THREE.PlaneGeometry(1000, 1000), new THREE.MeshBasicMaterial({
    transparent: true,
    opacity: 0.5,
    visible: true
  }));
  scene.add(plane);
  plane.material.visible = false
  plane.rotation.x = -Math.PI / 2;
  pickables = [plane];

  let loader = new THREE.TextureLoader();
  let tex = loader.load ("https://i.imgur.com/GmthNU8.png");
  targetMesh = new THREE.Mesh(new THREE.CircleGeometry(10,20), new THREE.MeshBasicMaterial({
    map: tex,
    transparent:true
   }));
  scene.add(targetMesh);
  targetMesh.rotation.x = -Math.PI/2

  raycaster = new THREE.Raycaster();
  document.addEventListener('pointerdown', onDocumentMouseDown, false);
  ////////////////////////
    steve=new human(WW,HH);
    steve.buildHuman(WW,HH);

  readModel('bus');
  var ambientLight = new THREE.AmbientLight(0xffffff);
  scene.add(ambientLight);
  const directionalLight = new THREE.DirectionalLight( 0xffffff);
  scene.add( directionalLight );

  scene.obstacles = [];
  scene.obstacles.push ( new Obstacle (new THREE.Vector3(50,0,50), 20) )
  scene.obstacles.push ( new Obstacle (new THREE.Vector3(-50,0,40), 10) )
  scene.obstacles.push ( new Obstacle (new THREE.Vector3(0,0,30), 15) )
}

function onDocumentMouseDown(event) {

  event.preventDefault();
  mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
  mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

  // find intersections
  raycaster.setFromCamera(mouse, camera);
  var intersects = raycaster.intersectObjects(pickables);
  if (intersects.length > 0) {
    targetMesh.position.copy(intersects[0].point);
    targetMesh.position.y = 0.15
    agent.setTarget (intersects[0].point.x,16, intersects[0].point.z);
  }

}

var hasbus=0;
function animate() {
  let dt = clock.getDelta();

  requestAnimationFrame(animate);
  render();

  if(bus != undefined)
  {  
    if(hasbus==0){
     agent = new Agent(new THREE.Vector3(100,25,0),bus);
   hasbus=1;
   }
   steve.update(dt); 
   agent.update(dt);
  }
  
}

function render() {
  renderer.render(scene, camera);
}


</script>

</body>
</html>